<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resources Notifier Test Client</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 800px; margin: 0 auto; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .connected { background-color: #d4edda; color: #155724; }
        .disconnected { background-color: #f8d7da; color: #721c24; }
        .messages { border: 1px solid #ddd; height: 300px; overflow-y: auto; padding: 10px; margin: 10px 0; }
        .message { margin: 5px 0; padding: 5px; background-color: #f8f9fa; border-left: 3px solid #007bff; }
        input, button { padding: 8px; margin: 5px; }
        input[type="text"] { width: 200px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Notification Hub Test Client</h1>
        
        <div id="status" class="status disconnected">Disconnected</div>
        
        <div>
            <h3>Resources Channel</h3>
            <label>Business ID:</label>
            <input type="text" id="businessId" value="test-business-001" />
            
            <label>Location ID:</label>
            <input type="text" id="locationId" value="location-001" />
            
            <button onclick="connectResources()">Connect Resources</button>
            <button onclick="disconnectResources()">Disconnect Resources</button>
        </div>
        
        <div>
            <h3>Messages Channel</h3>
            <label>Tenant ID:</label>
            <input type="text" id="tenantId" value="test-tenant" />
            
            <button onclick="connectMessages()">Connect Messages</button>
            <button onclick="disconnectMessages()">Disconnect Messages</button>
        </div>
        
        <div class="messages" id="messages"></div>
        
        <div>
            <h3>Test Resource Update</h3>
            <p>To test real notifications:</p>
            <h4>1. Resource Updates (from resources server):</h4>
            <pre>curl -X POST http://localhost:3002/resources/business-123-location-456 \
  -H "Content-Type: application/json" \
  -H "X-Business-ID: business-123" \
  -H "X-Location-ID: location-456" \
  -H "X-Resource-Type: reservation" \
  -d '{"data": {"customerName": "John Doe"}}'</pre>
            
            <h4>2. AI Agent Messages:</h4>
            <pre>curl -X POST http://localhost:4000/api/messages \
  -H "Content-Type: application/json" \
  -d '{
    "tenant_id": "test-tenant",
    "user_id": "user-123", 
    "session_id": "session-456",
    "content": "Hello AI agent!"
  }'</pre>
            <button onclick="simulateUpdate()">Simulate Local Update</button>
        </div>
    </div>

    <script>
        let socket = null;
        let resourcesChannel = null;
        let messagesChannel = null;

        function connectResources() {
            const businessId = document.getElementById('businessId').value;
            const locationId = document.getElementById('locationId').value;
            
            if (!businessId || !locationId) {
                alert('Please enter both Business ID and Location ID');
                return;
            }

            // Import Phoenix Socket (you'll need to include phoenix.js)
            socket = new Phoenix.Socket('/socket', {});
            socket.connect();

            const channelTopic = `resources:${businessId}-${locationId}`;
            resourcesChannel = socket.channel(channelTopic, {});

            resourcesChannel.join()
                .receive('ok', resp => {
                    console.log('Joined resources channel successfully', resp);
                    updateStatus('Connected to ' + channelTopic, true);
                })
                .receive('error', resp => {
                    console.log('Unable to join resources channel', resp);
                    updateStatus('Failed to connect: ' + JSON.stringify(resp), false);
                });

            resourcesChannel.on('resource_update', payload => {
                console.log('Resource update received:', payload);
                addMessage('Resource Update', payload);
            });

            socket.onError(() => {
                updateStatus('Socket error', false);
            });

            socket.onClose(() => {
                updateStatus('Socket closed', false);
            });
        }

        function connectMessages() {
            const tenantId = document.getElementById('tenantId').value;
            
            if (!tenantId) {
                alert('Please enter Tenant ID');
                return;
            }

            if (!socket) {
                socket = new Phoenix.Socket('/socket', {});
                socket.connect();
            }

            const channelTopic = `messages:${tenantId}`;
            messagesChannel = socket.channel(channelTopic, {});

            messagesChannel.join()
                .receive('ok', resp => {
                    console.log('Joined messages channel successfully', resp);
                    updateStatus('Connected to ' + channelTopic, true);
                })
                .receive('error', resp => {
                    console.log('Unable to join messages channel', resp);
                    updateStatus('Failed to connect: ' + JSON.stringify(resp), false);
                });

            messagesChannel.on('new_message', payload => {
                console.log('New message received:', payload);
                addMessage('AI Agent Message', payload);
            });
        }

        function disconnectResources() {
            if (resourcesChannel) {
                resourcesChannel.leave();
                resourcesChannel = null;
            }
            updateStatus('Disconnected from resources', false);
        }

        function disconnectMessages() {
            if (messagesChannel) {
                messagesChannel.leave();
                messagesChannel = null;
            }
            updateStatus('Disconnected from messages', false);
        }

        function updateStatus(message, connected) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status ' + (connected ? 'connected' : 'disconnected');
        }

        function addMessage(type, payload) {
            const messagesEl = document.getElementById('messages');
            const messageEl = document.createElement('div');
            messageEl.className = 'message';
            messageEl.innerHTML = `
                <strong>${type}</strong> - ${new Date().toLocaleTimeString()}<br>
                <pre>${JSON.stringify(payload, null, 2)}</pre>
            `;
            messagesEl.appendChild(messageEl);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function simulateUpdate() {
            // This simulates what would be received from the notification hub
            const simulatedResourceUpdate = {
                type: 'resource_created',
                resourceType: 'reservation',
                businessId: document.getElementById('businessId').value,
                locationId: document.getElementById('locationId').value,
                resourceId: 'reservation-' + Date.now(),
                timestamp: new Date().toISOString()
            };

            const simulatedMessage = {
                message_id: 'msg-' + Date.now(),
                content: 'Hello from AI agent!',
                role: 'agent',
                timestamp: Date.now()
            };

            addMessage('Simulated Resource Update', simulatedResourceUpdate);
            addMessage('Simulated AI Message', simulatedMessage);
        }
    </script>

    <!-- You'll need to include Phoenix JavaScript client -->
    <script>
        // Minimal Phoenix Socket implementation for testing
        // In production, you should use the official phoenix.js
        class Phoenix {
            static Socket = class {
                constructor(endpoint, opts = {}) {
                    this.endpoint = endpoint;
                    this.opts = opts;
                    this.channels = [];
                    this.ws = null;
                }

                connect() {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}${this.endpoint}`;
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => console.log('WebSocket connected');
                    this.ws.onclose = () => this.onClose && this.onClose();
                    this.ws.onerror = () => this.onError && this.onError();
                    this.ws.onmessage = (event) => this.handleMessage(JSON.parse(event.data));
                }

                disconnect() {
                    if (this.ws) {
                        this.ws.close();
                        this.ws = null;
                    }
                }

                channel(topic, params = {}) {
                    const channel = new Phoenix.Channel(topic, params, this);
                    this.channels.push(channel);
                    return channel;
                }

                handleMessage(message) {
                    const channel = this.channels.find(ch => ch.topic === message.topic);
                    if (channel) {
                        channel.handleMessage(message);
                    }
                }

                send(message) {
                    if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                        this.ws.send(JSON.stringify(message));
                    }
                }
            }

            static Channel = class {
                constructor(topic, params, socket) {
                    this.topic = topic;
                    this.params = params;
                    this.socket = socket;
                    this.bindings = {};
                    this.joinRef = null;
                }

                join() {
                    this.joinRef = Date.now().toString();
                    const message = {
                        topic: this.topic,
                        event: 'phx_join',
                        payload: this.params,
                        ref: this.joinRef
                    };
                    this.socket.send(message);

                    return {
                        receive: (status, callback) => {
                            this.on(`phx_reply_${this.joinRef}`, (payload) => {
                                if (payload.status === status) {
                                    callback(payload.response);
                                }
                            });
                            return this;
                        }
                    };
                }

                leave() {
                    const message = {
                        topic: this.topic,
                        event: 'phx_leave',
                        payload: {},
                        ref: Date.now().toString()
                    };
                    this.socket.send(message);
                }

                on(event, callback) {
                    if (!this.bindings[event]) {
                        this.bindings[event] = [];
                    }
                    this.bindings[event].push(callback);
                }

                handleMessage(message) {
                    const callbacks = this.bindings[message.event] || [];
                    callbacks.forEach(callback => callback(message.payload));
                }
            }
        }

        // Make Phoenix available globally
        window.Phoenix = Phoenix;
    </script>
</body>
</html>