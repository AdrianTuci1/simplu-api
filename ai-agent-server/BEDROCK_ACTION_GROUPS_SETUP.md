# AWS Bedrock Action Groups - Ghid de Configurare CompletƒÉ

## Prezentare GeneralƒÉ

Action Groups permit Bedrock Agent sƒÉ apeleze func»õii (tools) din aplica»õia ta pentru a executa ac»õiuni specifice. Fiecare Action Group trebuie configurat √Æn AWS Console cu schema OpenAPI.

## üìã Pa»ôi de Configurare

### Pasul 1: AcceseazƒÉ Bedrock Agent

1. Deschide **AWS Console**
2. NavigheazƒÉ la **Amazon Bedrock** ‚Üí **Agents**
3. SelecteazƒÉ agent-ul tƒÉu (sau creeazƒÉ unul nou)
4. Click pe tab-ul **Action groups**

### Pasul 2: CreeazƒÉ Action Groups

Vei crea **3 Action Groups** principale:

---

## üîß Action Group 1: Query Tools (READ-ONLY)

**Scop**: InterogƒÉri read-only pentru date (appointments, patients, services, etc.)

### Configurare √Æn AWS Console:

1. Click **Add Action Group**
2. CompleteazƒÉ:
   - **Name**: `query_tools`
   - **Description**: `Read-only queries for business data including appointments, patients, services, and resources`
   - **Action group type**: `Define with API schemas`
   - **Action group invocation**: `Return control` (sau `Lambda` dacƒÉ vrei callback)
   - **Action group schema**: `Define with in-line OpenAPI schema editor`

3. **OpenAPI Schema** - copiazƒÉ urmƒÉtoarea schemƒÉ:

```json
{
  "openapi": "3.0.0",
  "info": {
    "title": "Query Tools API",
    "version": "1.0.0",
    "description": "Read-only queries for business data"
  },
  "paths": {
    "/query_app_server": {
      "post": {
        "summary": "Query app server for resources and patient booking data",
        "description": "READ-ONLY queries to app server. For modifications use call_frontend_function instead. Supports two modules: 1) PATIENT-BOOKING (for customers/patients) - Get available services, check time slots, view appointment history. 2) RESOURCES (for operators) - List and get resources (appointments, patients, treatments, medics, etc.)",
        "operationId": "query_app_server",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": ["module", "action", "businessId", "locationId"],
                "properties": {
                  "module": {
                    "type": "string",
                    "enum": ["patient-booking", "resources"],
                    "description": "Module to query: patient-booking (for customers) or resources (for operators)"
                  },
                  "action": {
                    "type": "string",
                    "description": "READ-ONLY action: services, slots, history (patient-booking) or list, get (resources with resourceType)"
                  },
                  "businessId": {
                    "type": "string",
                    "description": "Business ID"
                  },
                  "locationId": {
                    "type": "string",
                    "description": "Location ID"
                  },
                  "resourceType": {
                    "type": "string",
                    "description": "Resource type (REQUIRED for resources module): appointment, patient, treatment, medic, service, etc."
                  },
                  "resourceId": {
                    "type": "string",
                    "description": "Resource ID (for get action only)"
                  },
                  "params": {
                    "type": "object",
                    "description": "Query parameters (filters, pagination, date ranges, etc.)"
                  },
                  "accessCode": {
                    "type": "string",
                    "description": "Patient access code (for patient-booking history)"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful query",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "success": {
                      "type": "boolean"
                    },
                    "data": {
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/query_management_server": {
      "post": {
        "summary": "Query management server for business configuration",
        "description": "Queries the management server for business configuration, settings, subscriptions, invitations, and administrative data",
        "operationId": "query_management_server",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": ["endpoint", "method"],
                "properties": {
                  "endpoint": {
                    "type": "string",
                    "description": "The API endpoint to query (e.g., /api/businesses, /api/subscriptions)"
                  },
                  "method": {
                    "type": "string",
                    "enum": ["GET", "POST", "PUT", "PATCH", "DELETE"],
                    "description": "HTTP method to use"
                  },
                  "params": {
                    "type": "object",
                    "description": "Query parameters for GET requests"
                  },
                  "body": {
                    "type": "object",
                    "description": "Request body for POST/PUT/PATCH requests"
                  },
                  "tenantId": {
                    "type": "string",
                    "description": "Business ID (tenant ID) for multi-tenant queries"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful query",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "success": {
                      "type": "boolean"
                    },
                    "data": {
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

4. Click **Save**

---

## üñ•Ô∏è Action Group 2: Frontend Interaction Tools

**Scop**: ApeleazƒÉ func»õii √Æn frontend pentru modificƒÉri (CREATE, UPDATE, DELETE)

### Configurare √Æn AWS Console:

1. Click **Add Action Group**
2. CompleteazƒÉ:
   - **Name**: `frontend_tools`
   - **Description**: `Call JavaScript functions in frontend that handle API operations for creating, updating, and deleting resources`
   - **Action group type**: `Define with API schemas`
   - **Action group invocation**: `Return control`
   - **Action group schema**: `Define with in-line OpenAPI schema editor`

3. **OpenAPI Schema**:

```json
{
  "openapi": "3.0.0",
  "info": {
    "title": "Frontend Interaction Tools API",
    "version": "1.0.0",
    "description": "Tools for calling frontend functions that handle API operations"
  },
  "paths": {
    "/call_frontend_function": {
      "post": {
        "summary": "Call JavaScript functions in the frontend",
        "description": "Call JavaScript functions in the frontend that handle API operations. The frontend sends context with each message (current menu, edited resource). Based on conversation, AI calls frontend functions to complete actions. Common functions: createResource, updateResource, deleteResource, submitForm, navigateTo, selectResource, closeModal",
        "operationId": "call_frontend_function",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": ["functionName"],
                "properties": {
                  "functionName": {
                    "type": "string",
                    "description": "Function to call in frontend (createResource, updateResource, deleteResource, submitForm, navigateTo, selectResource, closeModal, etc.)"
                  },
                  "parameters": {
                    "type": "object",
                    "description": "Parameters to pass to the function",
                    "properties": {
                      "resourceType": {
                        "type": "string",
                        "description": "Resource type (appointment, patient, treatment, medic, service, etc.)"
                      },
                      "resourceId": {
                        "type": "string",
                        "description": "Resource ID (for update, delete, select)"
                      },
                      "data": {
                        "type": "object",
                        "description": "Data to create or update (resource fields)"
                      },
                      "view": {
                        "type": "string",
                        "description": "View to navigate to (appointments, patients, calendar, etc.)"
                      }
                    }
                  },
                  "businessId": {
                    "type": "string",
                    "description": "Business ID"
                  },
                  "locationId": {
                    "type": "string",
                    "description": "Location ID"
                  },
                  "sessionId": {
                    "type": "string",
                    "description": "Session ID"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Function call sent to frontend",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "success": {
                      "type": "boolean"
                    },
                    "data": {
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

4. Click **Save**

---

## üì¢ Action Group 3: Notification Tools

**Scop**: Trimite notificƒÉri »ôi mesaje externe (Meta, Twilio, Email, WebSocket)

### Configurare √Æn AWS Console:

1. Click **Add Action Group**
2. CompleteazƒÉ:
   - **Name**: `notification_tools`
   - **Description**: `Send notifications and external messages via Meta, Twilio, Email, and WebSocket`
   - **Action group type**: `Define with API schemas`
   - **Action group invocation**: `Return control`
   - **Action group schema**: `Define with in-line OpenAPI schema editor`

3. **OpenAPI Schema**:

```json
{
  "openapi": "3.0.0",
  "info": {
    "title": "Notification Tools API",
    "version": "1.0.0",
    "description": "Tools for sending notifications and external messages"
  },
  "paths": {
    "/send_external_message": {
      "post": {
        "summary": "Send external message via Meta, Twilio, or Email",
        "description": "Send messages through external channels (Meta WhatsApp, Twilio SMS, Gmail)",
        "operationId": "send_external_message",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": ["channel", "recipient", "message"],
                "properties": {
                  "channel": {
                    "type": "string",
                    "enum": ["meta", "twilio", "gmail"],
                    "description": "Communication channel to use"
                  },
                  "recipient": {
                    "type": "string",
                    "description": "Recipient identifier (phone number or email)"
                  },
                  "message": {
                    "type": "string",
                    "description": "Message content to send"
                  },
                  "businessId": {
                    "type": "string",
                    "description": "Business ID"
                  },
                  "metadata": {
                    "type": "object",
                    "description": "Additional metadata for the message"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Message sent successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "success": {
                      "type": "boolean"
                    },
                    "messageId": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/send_elixir_notification": {
      "post": {
        "summary": "Send notification to frontend via Elixir server",
        "description": "Send real-time notifications to frontend users through Elixir WebSocket server",
        "operationId": "send_elixir_notification",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": ["businessId", "userId", "message"],
                "properties": {
                  "businessId": {
                    "type": "string",
                    "description": "Business ID"
                  },
                  "userId": {
                    "type": "string",
                    "description": "User ID to notify"
                  },
                  "message": {
                    "type": "string",
                    "description": "Notification message"
                  },
                  "notificationType": {
                    "type": "string",
                    "description": "Type of notification (info, success, warning, error)"
                  },
                  "metadata": {
                    "type": "object",
                    "description": "Additional notification data"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Notification sent successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "success": {
                      "type": "boolean"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/broadcast_websocket_message": {
      "post": {
        "summary": "Broadcast message to multiple WebSocket clients",
        "description": "Send broadcast messages to all connected clients or specific rooms",
        "operationId": "broadcast_websocket_message",
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "required": ["businessId", "message"],
                "properties": {
                  "businessId": {
                    "type": "string",
                    "description": "Business ID"
                  },
                  "locationId": {
                    "type": "string",
                    "description": "Location ID (optional, for specific location)"
                  },
                  "message": {
                    "type": "string",
                    "description": "Broadcast message content"
                  },
                  "event": {
                    "type": "string",
                    "description": "WebSocket event name"
                  },
                  "targetUsers": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "description": "Optional list of specific user IDs to broadcast to"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Broadcast sent successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "success": {
                      "type": "boolean"
                    },
                    "recipientCount": {
                      "type": "number"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

4. Click **Save**

---

## üìö Pasul 3: AsociazƒÉ Knowledge Base la Agent

**De ce este necesar?** Knowledge Base permite agentului sƒÉ acceseze:
- Documenta»õie specificƒÉ business-ului (dental, gym, hotel)
- Instruc»õiuni pentru operatori »ôi clien»õi
- Structuri de date »ôi configurƒÉri
- Context »ôi best practices

### Configurare √Æn AWS Console:

1. √én pagina Agent-ului, mergi la tab-ul **Knowledge bases**
2. Click **Add** sau **Associate knowledge base**

### Op»õiunea A: CreeazƒÉ Knowledge Base Nou

DacƒÉ nu ai √ÆncƒÉ un Knowledge Base:

1. Click **Create and add knowledge base**
2. CompleteazƒÉ:
   - **Name**: `simplu-dental-kb` (sau numele business-ului tƒÉu)
   - **Description**: `Knowledge base for dental clinic operations and documentation`
   - **IAM role**: Create new service role

3. **Data source configuration**:
   - **Data source type**: Amazon S3
   - **S3 URI**: `s3://your-bucket-name/dental/` (bucketul unde ai documentele)
   - **Chunking strategy**: Default (300 tokens with 20% overlap)

4. **Embeddings model**:
   - SelecteazƒÉ: `amazon.titan-embed-text-v2:0` (recomandat pentru cost/performan»õƒÉ)
   - Alternativ: `amazon.titan-embed-text-v1` sau `cohere.embed-english-v3`

5. **Vector database**:
   - **Recommended**: Amazon OpenSearch Serverless (Quick create)
   - Alternativ: Pinecone, Redis Enterprise, MongoDB Atlas

6. Click **Create knowledge base**

7. DupƒÉ creare, click **Sync** pentru a procesa documentele

8. **CopiazƒÉ Knowledge Base ID** ‚Üí `.env` la `BEDROCK_KNOWLEDGE_BASE_ID`

### Op»õiunea B: AsociazƒÉ Knowledge Base Existent

DacƒÉ ai deja un Knowledge Base:

1. Click **Add existing knowledge base**
2. SelecteazƒÉ Knowledge Base-ul din listƒÉ
3. **Instructions for Agent** (op»õional dar recomandat):
   ```
   Use this knowledge base to answer questions about:
   - Dental procedures and treatments
   - Appointment booking policies
   - Patient care instructions
   - Clinic operating procedures
   - Resource management guidelines
   
   Always cite the knowledge base when providing specific information about clinic policies or procedures.
   ```

4. Click **Associate**

### VerificƒÉ Documentele √Æn S3

AsigurƒÉ-te cƒÉ ai documentele necesare √Æn S3:

```bash
# ListeazƒÉ documentele din S3
aws s3 ls s3://your-bucket-name/dental/ --recursive

# Ar trebui sƒÉ vezi:
# dental/_metadata.json
# dental/dental-customer-instructions.json
# dental/dental-operator-instructions.json
# dental/dental-resource-structure.json
# dental/dental-data-field-structure.json
# dental/dental-resource-setting.json
```

### PregƒÉte»ôte Documente pentru Knowledge Base

DacƒÉ nu ai √ÆncƒÉ documentele √Æn S3, ruleazƒÉ scriptul:

```bash
cd ai-agent-server

# VerificƒÉ documentele locale
ls data/kb-documents/dental/

# Sync documentele √Æn S3 (dacƒÉ ai configurat scriptul)
./scripts/sync-kb-documents.sh dental

# SAU folose»ôte setup-ul complet
./scripts/setup-s3-vectors-kb.sh
```

### Test Knowledge Base

DupƒÉ sincronizare, testeazƒÉ cƒÉ func»õioneazƒÉ:

1. √én AWS Console ‚Üí Bedrock ‚Üí Knowledge bases
2. SelecteazƒÉ knowledge base-ul tƒÉu
3. Click pe **Test** tab
4. Introdu o √Æntrebare: "Care sunt instruc»õiunile pentru programƒÉri?"
5. VerificƒÉ cƒÉ returneazƒÉ rezultate relevante

### ConfigureazƒÉ Agent sƒÉ foloseascƒÉ Knowledge Base

1. √én pagina Agent-ului, mergi la **Agent instructions**
2. AdaugƒÉ instruc»õiuni despre c√¢nd sƒÉ foloseascƒÉ KB:

```
You are an AI assistant for a dental clinic management system.

When answering questions:
1. First check the knowledge base for clinic-specific policies and procedures
2. Use the knowledge base for information about:
   - Treatment types and procedures
   - Booking policies and availability rules
   - Patient care instructions
   - Data structures and field meanings
   
3. For real-time data (appointments, patients), use the query_app_server tool
4. For modifications (create, update, delete), use call_frontend_function tool
5. For notifications, use notification tools

Always prioritize accuracy. If unsure, ask for clarification rather than guessing.
```

3. Click **Save and exit**

### Monitorizare Knowledge Base Usage

√én log-urile aplica»õiei vei vedea c√¢nd KB este folosit:

```
üìö Knowledge Base retrieved 3 references
```

√én trace events vei vedea detalii:

```json
{
  "knowledgeBaseLookupOutput": {
    "retrievedReferences": [
      {
        "content": { "text": "..." },
        "location": { "s3Location": { "uri": "s3://..." } },
        "metadata": { ... }
      }
    ]
  }
}
```

---

## üîÑ Pasul 4: ConfigureazƒÉ Return Control (Op»õional)

DacƒÉ ai ales **"Return control"** la Action group invocation, Bedrock va returna controlul aplica»õiei tale c√¢nd vrea sƒÉ execute un tool. Trebuie sƒÉ:

1. **Procesezi evenimentul `returnControl`** √Æn `bedrock-agent.service.ts`
2. **Execu»õi tool-ul** folosind `ToolExecutorService`
3. **RƒÉspunzi √Ænapoi** la Bedrock cu rezultatul

### Op»õiunea 1: Return Control (Recommended)

Avantaje:
- Mai mult control asupra execu»õiei
- Logging detaliat √Æn aplica»õia ta
- Posibilitate de validare √Ænainte de execu»õie

Cod modificat √Æn `bedrock-agent.service.ts`:

```typescript
if (event.returnControl) {
  // Agent is requesting to invoke an action group
  const invocationInputs = event.returnControl.invocationInputs;
  
  for (const input of invocationInputs) {
    if (input.actionGroupInvocationInput) {
      const { actionGroupName, function: functionName, parameters } = input.actionGroupInvocationInput;
      
      this.logger.log(`üîß Bedrock requests tool execution: ${actionGroupName}::${functionName}`);
      
      // Execute tool locally
      const toolResult = await this.toolExecutorService.executeTool({
        toolName: functionName,
        parameters,
        context,
      });
      
      // Send result back to Bedrock (requires InvokeAgent with sessionState)
      // ... continue conversation with tool result
    }
  }
}
```

### Op»õiunea 2: Lambda Function

Alternativ, po»õi configura un **AWS Lambda** care executƒÉ tools-urile:

1. CreeazƒÉ Lambda function
2. ConfigureazƒÉ Action Group sƒÉ foloseascƒÉ Lambda ARN
3. Lambda prime»ôte request de la Bedrock »ôi executƒÉ tool-ul
4. Lambda returneazƒÉ rezultatul la Bedrock

---

## üìä Pasul 5: Prepare & Deploy Agent

DupƒÉ ce ai configurat toate Action Groups:

1. Click **Prepare** (√Æn partea de sus a paginii Agent)
   - Aceasta compileazƒÉ agent-ul cu noile Action Groups
   - Procesul dureazƒÉ ~1-2 minute

2. DupƒÉ prepare, verificƒÉ:
   - ‚úÖ Agent status: **Prepared**
   - ‚úÖ Action groups: 3 active
   - ‚úÖ Knowledge base: Associated (dacƒÉ ai)

3. **CreeazƒÉ Alias** (pentru production):
   - Click **Create Alias**
   - Name: `production` sau `v1`
   - Associate cu versiunea pregƒÉtitƒÉ
   - CopiazƒÉ **Alias ID** √Æn `.env` ‚Üí `BEDROCK_AGENT_ALIAS_ID`

**Pentru testing**, po»õi folosi direct `TSTALIASID` (draft alias)

---

## üß™ Pasul 6: Test Configura»õia

### Test √Æn AWS Console:

1. Mergi la tab-ul **Test** din Bedrock Agent
2. Scrie un mesaj: "Vreau sƒÉ vƒÉd lista de pacien»õi"
3. VerificƒÉ:
   - Agent invocƒÉ `query_app_server`
   - Trace aratƒÉ tool call »ôi rezultat
   - RƒÉspunsul include date prelucrate

### Test √Æn Aplica»õie:

```bash
# Start server
cd ai-agent-server
npm run start:dev

# Trimite mesaj
curl -X POST http://localhost:3003/api/messages \
  -H "Content-Type: application/json" \
  -d '{
    "tenant_id": "B0100001",
    "user_id": "test-user-123",
    "session_id": "test-session",
    "message_id": "msg_1",
    "payload": {
      "content": "C√¢te programƒÉri am azi?"
    }
  }'
```

**Log-uri a»ôteptate:**

```
üì§ Invoking Bedrock Agent for session: test-session
üì° Bedrock response received, processing stream...
üîÑ Starting to process event stream...
üì¶ Event received: ["trace"]
üìä Trace event received: { "orchestrationTrace": { ... }}
üîß Tool called: query_tools -> query_app_server
üìù Tool parameters: { "module": "resources", "action": "list", ... }
‚úÖ Tool output: {"success": true, "data": [...]}
‚ú® Stream processing complete. Tools used: 1, Actions: 0
üîß Tools used in this invocation: ["query_tools:query_app_server"]
‚úÖ Bedrock Agent invoked successfully in 2345ms
```

---

## üîç Troubleshooting

### Agent nu apeleazƒÉ tools

**Cauze posibile:**
1. Action Groups nu sunt **Prepared**
2. Schema OpenAPI are erori de sintaxƒÉ
3. Agent instructions nu men»õioneazƒÉ c√¢nd sƒÉ foloseascƒÉ tools
4. Knowledge Base rƒÉspunde suficient de bine

**Solu»õie:**
```bash
# VerificƒÉ agent status
aws bedrock-agent get-agent --agent-id YOUR_AGENT_ID

# Prepare agent din nou
aws bedrock-agent prepare-agent --agent-id YOUR_AGENT_ID
```

### Eroare: "Action group not found"

**CauzƒÉ:** Agent-ul nu a fost pregƒÉtit dupƒÉ adƒÉugarea Action Groups

**Solu»õie:** Click **Prepare** √Æn AWS Console

### Nu vƒÉd trace logs

**CauzƒÉ:** `enableTrace: true` nu este setat

**VerificƒÉ √Æn cod:**
```typescript
const command = new InvokeAgentCommand({
  enableTrace: true, // ‚Üê AsigurƒÉ-te cƒÉ e true
  // ...
});
```

### Tool execution failed

**VerificƒÉ:**
1. **Permissions**: Agent role are acces la Lambda (dacƒÉ folose»ôti)
2. **Schema mismatch**: Parametrii trimi»ôi de agent match schema
3. **Network**: ai-agent-server e accesibil pentru Lambda
4. **API Keys**: VerificƒÉ `AI_SERVER_KEY` »ôi alte creden»õiale

---

## üìö Resurse Suplimentare

- **AWS Documentation**: [Bedrock Agents User Guide](https://docs.aws.amazon.com/bedrock/latest/userguide/agents.html)
- **OpenAPI Spec**: [OpenAPI 3.0 Specification](https://swagger.io/specification/)
- **Project Docs**: 
  - `BEDROCK_SETUP.md` - Setup complet Bedrock
  - `QUICK_START.md` - Quick start guide
  - `src/modules/tools/README.md` - Tools architecture

---

## ‚úÖ Checklist Final

- [ ] Agent creat √Æn AWS Bedrock
- [ ] Action Group 1 (Query Tools) configurat cu schema OpenAPI
- [ ] Action Group 2 (Frontend Tools) configurat cu schema OpenAPI
- [ ] Action Group 3 (Notification Tools) configurat cu schema OpenAPI
- [ ] **Knowledge Base creat »ôi asociat la Agent**
- [ ] **Documente sincronizate √Æn S3**
- [ ] **Knowledge Base testat √Æn AWS Console**
- [ ] Agent **Prepared** cu succes
- [ ] Alias creat »ôi `BEDROCK_AGENT_ALIAS_ID` setat √Æn `.env`
- [ ] `BEDROCK_AGENT_ID` setat √Æn `.env`
- [ ] `BEDROCK_KNOWLEDGE_BASE_ID` setat √Æn `.env`
- [ ] Test √Æn AWS Console reu»ôit (vezi tool calls »ôi KB retrieval √Æn trace)
- [ ] Test √Æn aplica»õie reu»ôit (vezi log-uri detaliate)

**Gata! üéâ** Acum Bedrock Agent poate apela toate tools-urile din aplica»õia ta!

